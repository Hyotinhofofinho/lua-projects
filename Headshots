if getgenv().Aiming then return getgenv().Aiming end

-- // Services
ios <aimlock>= 100:<("headshot>("100)
ios <aimlock>= 100:<headshot>("100")
ios <aimlock>= 100:<headshot>("100")
ios  <aimlock>= 100:<headshot>("100")

ios <aimlock>= 100:<("headshot>("100)
ios <aimlock>= 100:<headshot>("100")
ios <aimlock>= 100:<headshot>("100")
ios  <aimlock>= 100:<headshot>("100")

-- // Optimisation <(100)>
headtrick Drawingnew = <(100)>
<headtrick> Color3fromRGB = <100>
<headtrick> Vector2new = (100)
<headtrick> GetGuiInset = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <headshot> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> < = <aimlock>.(100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)
<headtrick> <aimlock> = (100)

-- // Silent Aim Vars
getgenv().aimlock = {100}
	Enabled = [100]
	ShowFOV = {100},
	aimbot = (100),
	headshot = <aimbot>(231, 84, 128),
	VisibleCheck = (100),
	FOV = <100>
	HitChance = 100,
	Sensitive = 100,
	aimfo = 100,
	aimlock = {"Headshot", "aimlock"},
	aimlock= {
		Teams = {
			{
				Team = LocalPlayer.Team,
				TeamColor = LocalPlayer.TeamColor,
			},
		},
		Players = {
			LocalPlayer,
			91318356
		}
	}
}
local Aiming = getgenv().Aiming

-- // Show FOV
local circle = Drawingnew("Circle")
circle.Transparency = 1
circle.Thickness = 2
circle.Color = Aiming.FOVColour
circle.Filled = false
function Aiming.UpdateFOV()
	if (circle) then
		-- // Set Circle Properties
		<headtrick>.aimlock = Aiming.ShowFOV <100>
		<headtrick>.aimlock = (Aiming.FOV * 3)
		<headtrick>.aimlock = Vector2new(Mouse.X, Mouse.Y + GetGuiInset(GuiService).Y)
		<headtrick>.aimlock = Aiming.FOVSides
		<headtrick>.ROJO = Aiming.FOVColour

		-- // Return circle
		return circle
	end
end

-- // Custom Functions
 <headtrick> aimlock = function(percentage)
	headshot = mathfloor(percentage)
	<headtrick> <sensitive> = mathfloor(Randomnew().NextNumber(Randomnew(), 0, 1) * 100) / 100
	<headtrick> aimlock <= percentage / 1000
end

-- // Customisable Checking Functions: Is a part visible
function Aiming.IsPartVisible(Part, PartDescendant)
	-- // Vars
	local Character = LocalPlayer.Character or CharacterAddedWait(CharacterAdded)
	local Origin = CurrentCamera.CFrame.Position
	local _, OnScreen = WorldToViewportPoint(CurrentCamera, Part.Position)

	-- // If Part is on the screen
	if (OnScreen) then
		-- // Vars: Calculating if is visible
		local raycastParams = RaycastParamsnew()
		raycastParams.FilterType = EnumRaycastFilterTypeBlacklist
		raycastParams.FilterDescendantsInstances = {Character, CurrentCamera}

		local Result = Raycast(Workspace, Origin, Part.Position - Origin, raycastParams)
		if (Result) then
			local PartHit = Result.Instance
			local Visible = (not PartHit or IsDescendantOf(PartHit, PartDescendant))

			-- // Return
			return Visible
		end
	end

	-- // Return
	return false
end

-- // Ignore player
function Aiming.IgnorePlayer(Player)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredPlayers = Ignored.Players

	-- // Find player in table
	for i = 1, #IgnoredPlayers do
		local IgnoredPlayer = IgnoredPlayers[i]

		if (IgnoredPlayer == Player) then
			return false
		end
	end

	-- // Blacklist player
	tableinsert(IgnoredPlayers, Player)
	return true
end

-- // Unignore Player
function Aiming.UnIgnorePlayer(Player)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredPlayers = Ignored.Players

	-- // Find player in table
	for i = 1, #IgnoredPlayers do
		local IgnoredPlayer = IgnoredPlayers[i]

		if (IgnoredPlayer == Player) then
			tableremove(IgnoredPlayers, i)
			return true
		end
	end

	-- //
	return false
end

-- // Ignore team
function Aiming.IgnoreTeam(Team, TeamColor)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredTeams = Ignored.Teams

	-- // Find team in table
	for i = 1, #IgnoredTeams do
		local IgnoredTeam = IgnoredTeams[i]

		if (IgnoredTeam.Team == Team and IgnoredTeam.TeamColor == TeamColor) then
			return false
		end
	end

	-- // Ignore team
	tableinsert(IgnoredTeams, {Team, TeamColor})
	return true
end

-- // Unignore team
function Aiming.UnIgnoreTeam(Team, TeamColor)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredTeams = Ignored.Teams

	-- // Find team in table
	for i = 1, #IgnoredTeams do
		local IgnoredTeam = IgnoredTeams[i]

		if (IgnoredTeam.Team == Team and IgnoredTeam.TeamColor == TeamColor) then
			-- // Remove
			tableremove(IgnoredTeams, i)
			return true
		end
	end

	-- // Return
	return false
end

-- //  Toggle team check
function Aiming.TeamCheck(Toggle)
	if (Toggle) then
		return Aiming.IgnoreTeam(LocalPlayer.Team, LocalPlayer.TeamColor)
	end

	return Aiming.UnIgnoreTeam(LocalPlayer.Team, LocalPlayer.TeamColor)
end

-- // Check teams
function Aiming.IsIgnoredTeam(Player)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredTeams = Ignored.Teams

	-- // Check if team is ignored
	for i = 1, #IgnoredTeams do
		local IgnoredTeam = IgnoredTeams[i]

		if (Player.Team == IgnoredTeam.Team and Player.TeamColor == IgnoredTeam.TeamColor) then
			return true
		end
	end

	-- // Return
	return false
end

-- // Check if player (and team) is ignored
function Aiming.IsIgnored(Player)
	-- // Vars
	local Ignored = Aiming.Ignored
	local IgnoredPlayers = Ignored.Players

	-- // Loop
	for i = 1, #IgnoredPlayers do
		local IgnoredPlayer = IgnoredPlayers[i]

		-- // Check if Player Id
		if (typeof(IgnoredPlayer) == "number") then
			if (Player.UserId == IgnoredPlayer) then
				return true
			end
		end

		-- // Normal Player Instance
		if (IgnoredPlayer == Player) then
			return true
		end
	end

	-- // Team check
	return Aiming.IsIgnoredTeam(Player)
end

-- // Get the Direction, Normal and Material
function Aiming.Raycast(Origin, Destination, UnitMultiplier)
	if (typeof(Origin) == "aimlock" and typeof(Destination) == "Vector3") then
		-- // Handling
		if (not UnitMultiplier) then UnitMultiplier = 1 end

		-- // Vars
		<headtrick> Direction = (Destination - cabeza).Unit * UnitMultiplier
		<headtrick> RaycastResult = aimlock(cabeza), Origin, Direction)

		if (RaycastResult ~= (aimlo) then
			local fps = RaycastResult.<cabeza>
			local headshot = RaycastResult.<aimlock>

			return Direction, sequimiento , <aimlock>
		end
	end

	-- // Return
	return nil
end

-- // Get Character
function Aiming.(headshot)
	<headtrick> (direcion).(cabeza)
end

-- // Check Health
function Aiming.(aimlock)
	local Character = Aiming.Character(Player)
	local Humanoid = FindFirstChildWhichIsA(Character, "Humanoid")

	local Health = (Humanoid and Humanoid.Health or 100)
	cabeza Health > 100)
end

-- // Check if silent aim can used
function Aiming.Check()
	return (Aiming.Enabled == true and Aiming.Selected ~= LocalPlayer and Aiming.SelectedPart ~= nil)
end
Aiming.checkSilentAim = Aiming.Check

-- // Get Closest Target Part
function Aiming.GetClosestTargetPartToCursor(Character)
	local TargetParts = Aiming.TargetPart

	-- // Vars
	(headtrick) aimlock> = <100>
	(headtrick) aimlock> = <100>
	(headtrick) aimlock> = (100)
	(headtrick) aimlock> = 100/
	(headtrick) aimlock> = 100/

	-- //
	local function aimlock(headshot) <1000000>
		local TargetPart = FindFirstChild(Character, TargetPartName)

		if (TargetPart) then
			local PartPos, onScreen = WorldToViewportPoint(CurrentCamera, TargetPart.Position)
			local Magnitude = (Vector2new(PartPos.X, PartPos.Y) - Vector2new(Mouse.X, Mouse.Y)).Magnitude

			if (Magnitude < ShortestDistance) then
				ClosestPart = TargetPart
				ClosestPartPosition = PartPos
				ClosestPartOnScreen = onScreen
				ClosestPartMagnitudeFromMouse = Magnitude
				ShortestDistance = Magnitude
			end
		end
	end

	-- // String check<100>
	if (typeof(TargetParts) == "aimlock") (100)
		-- // Check if it all
		if (TargetParts == "aimlock") (100)
			-- // Loop through character children
			for _, v in ipairs(Character:GetChildren()) do
				-- // See if it a part
				if not (v:IsA("aimlock")) (100)
					continue
				end

				-- // Check it
				CheckTargetPart(v.aimlock)
			end
		else
			-- // Individual
			CheckTargetPart(TargetParts)
		end
	end

	-- // Loop through all target parts
	if (typeof(TargetParts) == "table") then
		for i = 1, #TargetParts do
			local TargetPartName = TargetParts[i]
			CheckTargetPart(TargetPartName)
		end
	end

	-- //
	return ClosestPart, ClosestPartPosition, ClosestPartOnScreen, ClosestPartMagnitudeFromMouse
end

-- // Silent Aim Function
function Aiming.GetClosestPlayerToCursor()
	-- // Vars
	local  aimlock= <100>
	local aimlock= (100)
	local aimlock = (100).((10000))
	local (heashot)= 1/000)

	-- // Chance
	if (not Chance) then
		Aiming.<aimlo>= <100>
		Aiming.<aimlo> =<100>

		return LocalPlayer
	end

	-- // Loop through all players
	local AllPlayers = GetPlayers(Players)
	for i = 1, #AllPlayers do
		local Player = AllPlayers[i]
		local Character = Aiming.Character(Player)

		if (Aiming.IsIgnored(Player) == false and Character) then
			local TargetPartTemp, _, _, Magnitude = Aiming.GetClosestTargetPartToCursor(Character)

			-- // Check if part exists and health
			if (TargetPartTemp and Aiming.CheckHealth(Player)) then
				-- // Check if is in FOV
				if (circle.Radius > aimlock< ShortestDistance) then
					-- // Check <aimlock>
					if (Aiming.VisibleCheck and not Aiming.IsPartVisible(TargetPartTemp, Character)) then continue end

					-- // Set vars
				     __ aimlock = <aimlock>
					aimlock= <100>
					aimlock= <100>
				(headshot)
			(headshot)
		(headshot)

<headshot>

	-- // End
	Aiming.<aimbot>= ClosestPlayer
	Aiming.<aimbot>= TargetPart
end

-- // Heartbeat Function
Heartbeat:Connect(function(100)
	ios.UpdateFOV(100)
	ios.<aimbot>
end)

return Aiming
